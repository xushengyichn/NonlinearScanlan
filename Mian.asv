%% 导入数据
clc;clear;close all
hb_to_mm ( 'KMatrix.matrix', 'K.txt' );
hb_to_mm ( 'MMatrix.matrix', 'M.txt' );
hb_to_mm ( 'CMatrix.matrix', 'C.txt' );


%%map the node and matrix from the KMatrix.mapping and MMatrix.mapping 
Kdata = importdata('K.txt').data;
Kmatrix = zeros(Kdata(1,1),Kdata(1,2));
for i = 2:size(Kdata,1)
    Kmatrix(Kdata(i,1),Kdata(i,2)) = Kdata(i,3);
end

Mdata = importdata('M.txt').data;
Mmatrix = zeros(Mdata(1,1),Mdata(1,2));

for i = 2:size(Mdata,1)
    Mmatrix(Mdata(i,1),Mdata(i,2)) = Mdata(i,3);
end

Cdata = importdata('C.txt').data;
Cmatrix_DP = zeros(Cdata(1,1),Cdata(1,2));

for i = 2:size(Cdata,1)
    Cmatrix_DP(Cdata(i,1),Cdata(i,2)) = Cdata(i,3);
end
% 还原对角线以上元素，使之为对称阵, ANSYS只给出下三角矩阵
K =diag(diag(Kmatrix)/2)+Kmatrix-diag(diag(Kmatrix));
K = K+K';
M =diag(diag(Mmatrix)/2)+Mmatrix-diag(diag(Mmatrix));
M = M+M';
C =diag(diag(Cmatrix_DP)/2)+Cmatrix_DP-diag(diag(Cmatrix_DP));
C = C+C';
% 特征值分析，即计算频率Freq和振型Phi，50代表求50阶，SM表示从较小的特征值开始求解
calmodes=20;
[eig_vec,eig_val]=eigs(K,M,calmodes,'SM');
[nfdof,nfdof]=size(eig_vec);
for j=1:nfdof
    mnorm=sqrt(eig_vec(:,j)'*M*eig_vec(:,j));
    eig_vec(:,j)=eig_vec(:,j)/mnorm;%振型质量归一化
end
[omeg,w_order] =sort(sqrt(diag(eig_val)));
mode_vec=eig_vec(:,w_order);
Freq = omeg/(2*pi);

% save StiffMatrix.mat K M;
% save mode_vec.mat mode_vec

%% Calculate the damping matrix of the beam
xi=0.003;
% If set alpha=0
alpha=0;
% beta=2*xi./omeg;
% 
% C=zeros(calmodes,size(M,1),size(M,2));
% for t1=1:calmodes
%     C(t1,:,:)=alpha.*M+beta(t1).*K;
% end

% beta=2*xi./omeg(1);
beta=0.013699749746335;

C=zeros(calmodes,size(M,1),size(M,2));
for t1=1:calmodes
    C(t1,:,:)=alpha.*M+beta.*K;
end


%% TMD parameters
nTMD=2;
mTMD=[100 100];
% mTMD=[100 100]*10^-6;
cTMD=[2*mTMD(1)*omeg(1)*0.05 2*mTMD(2)*omeg(2)*0.05];
kTMD=[mTMD(1)*omeg(1)^2 mTMD(2)*omeg(2)^2];
nodeTMD=[50 20];   %Node number(location of the TMD)


%% Number of modes considered
nModes=20;
matrixsize=nTMD+nModes;
KMmapping = importmappingmatrix('KMatrix.mapping');

phiTMD=zeros(nTMD,nModes);
% phiTMD row:TMD for each loaction column:the mode shape at the each
% location of tmd
for t1=1:nTMD
    for t2=1:nModes
        position_index=KMmapping.MatrixEqn(find(and(KMmapping.Node==nodeTMD(t1),KMmapping.DOF=='UY')));
        phiTMD(t1,t2)=mode_vec(position_index,t2);
    end
end
clear t1 t2
%% Create the Mass matrix
MM=zeros(matrixsize,matrixsize);
for t1=1:matrixsize
    if t1<=nModes
        MM(t1,t1)=P_eq(t1,mode_vec,M);
    end
    if and(t1>nModes,t1<=matrixsize)
        MM(t1,t1)=mTMD(t1-nModes);
    end
end
clear t1 

%% Create the Damping matrix

CC=zeros(matrixsize,matrixsize);
for t1=1:matrixsize
    if t1<=nModes
        C_temp=Cmatrix(t1,C,M);
        CC(t1,t1)=P_eq(t1,mode_vec,C_temp);
    end
    if and(t1>nModes,t1<=matrixsize)
        CC(t1,t1)=cTMD(t1-nModes);
    end
end
clear t1 


for t1=1:nModes
    for t2=1:nTMD
        for t3=1:nModes
            temp_data=cTMD(t2)*phiTMD(t2,t3)*phiTMD(t2,t1);
            CC(t1,t3)=CC(t1,t3)+temp_data;
            clear temp_data
        end
        indextmdt2=nModes+t2;
        CC(t1,indextmdt2)=CC(t1,indextmdt2)-cTMD(t2)*phiTMD(t2,t1);
    end
end
clear t1 t2 t3

for t1=1:nTMD
    for t2=1:nModes
        temp_data=-cTMD(t1)*phiTMD(t1,t2);
        CC(nModes+t1,t2)=CC(nModes+t1,t2)+temp_data;
        clear temp_data
    end
end
clear t1



%% Create the Stiffness Matrix

KK=zeros(matrixsize,matrixsize);
for t1=1:matrixsize
    if t1<=nModes
        KK(t1,t1)=P_eq(t1,mode_vec,K);%P=parameters
    end
    if and(t1>nModes,t1<=matrixsize)
        KK(t1,t1)=kTMD(t1-nModes);
    end
end
clear t1


for t1=1:nModes
    for t2=1:nTMD
        for t3=1:nModes
            temp_data=kTMD(t2)*phiTMD(t2,t3)*phiTMD(t2,t1);
            KK(t1,t3)=KK(t1,t3)+temp_data;
            clear temp_data
        end
        indextmdt2=nModes+t2;
        KK(t1,indextmdt2)=KK(t1,indextmdt2)-kTMD(t2)*phiTMD(t2,t1);
    end
end
clear t1 t2 t3

for t1=1:nTMD
    for t2=1:nModes
        temp_data=-kTMD(t1)*phiTMD(t1,t2);
        KK(nModes+t1,t2)=KK(nModes+t1,t2)+temp_data;
        clear temp_data
    end
end
clear t1


%% 特征值分析
clear eig_vec eig_val nfdof mode_vec omeg w_order
calmodes=20;
[eig_vec,eig_val]=eigs(KK,MM,calmodes,'SM');
[nfdof,nfdof]=size(eig_vec);
for j=1:nfdof
    mnorm=sqrt(eig_vec(:,j)'*MM*eig_vec(:,j));
    disp(mnorm)
    eig_vec(:,j)=eig_vec(:,j)/mnorm;%振型质量归一化
end
[omeg,w_order] =sort(sqrt(diag(eig_val)));
mode_vec2=eig_vec(:,w_order);
Freq2 = omeg/(2*pi);

%% 导入ansys增加TMD后的矩阵
clear eig_vec eig_val nfdof mode_vec omeg w_order
hb_to_mm ( 'KMatrixTMD.matrix', 'KTMD.txt' );
hb_to_mm ( 'MMatrixTMD.matrix', 'MTMD.txt' );
hb_to_mm ( 'CMatrixTMD.matrix', 'CTMD.txt' );
clear Kdata Kmatrix Mdata Mmatrix Cdata Cmatrix_DP K C M
%%map the node and matrix from the KMatrix.mapping and MMatrix.mapping 
Kdata = importdata('KTMD.txt').data;
Kmatrix = zeros(Kdata(1,1),Kdata(1,2));
for i = 2:size(Kdata,1)
    Kmatrix(Kdata(i,1),Kdata(i,2)) = Kdata(i,3);
end

Mdata = importdata('MTMD.txt').data;
Mmatrix = zeros(Mdata(1,1),Mdata(1,2));

for i = 2:size(Mdata,1)
    Mmatrix(Mdata(i,1),Mdata(i,2)) = Mdata(i,3);
end

Cdata = importdata('CTMD.txt').data;
Cmatrix_DP = zeros(Cdata(1,1),Cdata(1,2));

for i = 2:size(Cdata,1)
    Cmatrix_DP(Cdata(i,1),Cdata(i,2)) = Cdata(i,3);
end
% 还原对角线以上元素，使之为对称阵, ANSYS只给出下三角矩阵
K =diag(diag(Kmatrix)/2)+Kmatrix-diag(diag(Kmatrix));
K = K+K';
M =diag(diag(Mmatrix)/2)+Mmatrix-diag(diag(Mmatrix));
M = M+M';
C =diag(diag(Cmatrix_DP)/2)+Cmatrix_DP-diag(diag(Cmatrix_DP));
C = C+C';
% 特征值分析，即计算频率Freq和振型Phi，50代表求50阶，SM表示从较小的特征值开始求解
calmodes=20;
[eig_vec,eig_val]=eigs(K,M,calmodes,'SM');
[nfdof,nfdof]=size(eig_vec);
for j=1:nfdof
    mnorm=sqrt(eig_vec(:,j)'*M*eig_vec(:,j));
    eig_vec(:,j)=eig_vec(:,j)/mnorm;%振型质量归一化
end
[omeg,w_order] =sort(sqrt(diag(eig_val)));
mode_vec3=eig_vec(:,w_order);
Freq3 = omeg/(2*pi);


nModes=20;
matrixsize=nTMD+nModes;
KMmapping = importmappingmatrix('KMatrixTMD.mapping');
phiTMD3=zeros(nTMD,nModes);
nodeTMD3=[10001 10002];
% phiTMD row:TMD for each loaction column:the mode shape at the each
% location of tmd
for t1=1:nTMD
    for t2=1:nModes
        position_index=KMmapping.MatrixEqn(find(and(KMmapping.Node==nodeTMD3(t1),KMmapping.DOF=='UY')));
        phiTMD3(t1,t2)=mode_vec3(position_index,t2);
    end
end
clear t1 t2

%调整ANSYS振型使之与matlab对应
for t1=1:size(phiTMD3,2)
    decidevalue=phiTMD3(end,t1)/mode_vec2(end,t1);
    if decidevalue<0
        phiTMD3(:,t1)=phiTMD3(:,t1)*-1;
        mode_vec3(:,t1)=mode_vec3(:,t1)*-1;
    end
end



%% Calculate the response
% dt=0.01;
% T=600;
% t=0:dt:T;
% P1=10;
% Pmode1=10;
points=101;
% P_eachpoint1=P_mode_eachpoint(1,KMmapping,10,points,omeg,t,mode_vec);
% % % P_eachpoint2=P_mode_eachpoint(2,KMmapping,-1000,points,omeg,t,mode_vec);
% % P_eachpoint=P_eachpoint1;
% % % +P_eachpoint2;
% P_eachpoint2=P_mode_eachpoint(2,KMmapping,-1000,points,omeg,t,mode_vec);
% P_eachpoint=P_eachpoint1+P_eachpoint2;
fangdaxishu=10;
fangdaxishu2=10;
zhenxing1=0.99950656036565;
zhenxing2=0.92977648588731;
PI=3.14159265359;
FRE=0.069704171453635;	
FRE2=0.278900577315756;
THETA=2*PI*FRE;
THETA2=2*PI*FRE2;
dt=0.01;		
% !计算时间（秒）
T=300;
NNT=T/dt;
t=1:dt:T;
P1=fangdaxishu*zhenxing1*sin(THETA*t);
P2=fangdaxishu2*zhenxing2*sin(THETA2*t)*10;
P_eachpoint=zeros(points,length(t));
P_eachpoint(50,:)=P1;
P_eachpoint(20,:)=P2;
P=zeros(matrixsize,length(t));
for t1=1:matrixsize
    if t1<=nModes
        P(t1,:)=Peq(t1,mode_vec3,KMmapping,P_eachpoint,points,t);
    else
        P(t1,:)=zeros(1,size(t,2));
    end
end
% rng(0)
% clear P
% P=randi(8,matrixsize,length(t)) ;

nbeta=0.25;
ngam=0.5;
u0=zeros(matrixsize,1);
udot0=zeros(matrixsize,1);
[u udot u2dot] = NewmarkInt(t,MM,CC,KK,P,ngam,nbeta,u0,udot0);

% figure()
% grid on;
% plot(t,u(1,:),'b');
% xlabel('Time [s]'); ylabel('displacement of generalized coordinate'); 
% 
% figure()
% plot(t,u(end-1,:),'b')
% xlabel('Time [s]'); ylabel('displacement of TMD'); 

close all
pointnumber=50;%查看某个点的振动时程
phiResult=phiY(pointnumber,KMmapping,mode_vec3,nModes);
Dis=zeros(1,length(t));
for t1=1:nModes
    Dis=Dis+phiResult(t1).*u(t1,:);
end
figure()
plot(t,Dis,'b')
xlabel('Time [s]'); ylabel("displacement of point:"+num2str(pointnumber)); 
title("comparison of the displacement of midpoint calculated by matlab and ANSYS")
hold on

% close all
pointnumber=20;%查看某个点的振动时程
phiResult=phiY(pointnumber,KMmapping,mode_vec3,nModes);
Dis=zeros(1,length(t));
for t1=1:nModes
    Dis=Dis+phiResult(t1).*u(t1,:);
end
figure()
plot(t,Dis,'b')
xlabel('Time [s]'); ylabel("displacement of point:"+num2str(pointnumber)); 
title("comparison of the displacement of midpoint calculated by matlab and ANSYS")
hold on


pointnumber=10001;%查看某个点的振动时程

figure()
plot(t,U(end-1,:),'b')
xlabel('Time [s]'); ylabel("displacement of point:"+num2str(pointnumber)); 
title("comparison of the displacement of TMD1")
hold on


pointnumber=10002;%查看某个点的振动时程
figure()
plot(t,U(end,:),'b')
xlabel('Time [s]'); ylabel("displacement of point:"+num2str(pointnumber)); 
title("comparison of the displacement of TMD1")
hold on
% % xlim([0 500])
% dataANSYS_TMD=readmatrix("T_DIS_2modes_nodamping.txt");
% % dataANSYS_TMD=readmatrix("T_DIS.txt");
% dataANSYS_TMD=dataANSYS_TMD(2:end,:);
% plot(dataANSYS_TMD(:,1),dataANSYS_TMD(:,2),'r')
% legend("matlab","ANSYS")

% figure()
% plot(t,u(end-1,:),'b')
% xlabel('Time [s]'); ylabel('displacement of TMD'); 
% title("comparison of the displacement of TMD calculated by matlab and ANSYS")
% hold on
% 
% dataANSYS_TMD1=readmatrix("TMD_DIS_NODamping.txt");
% dataANSYS_TMD1=dataANSYS_TMD1(2:end,:);
% plot(dataANSYS_TMD1(:,1),dataANSYS_TMD1(:,2),'r')
% legend("matlab","ANSYS")

%% Compare with ANSYS
% dataANSYS=readmatrix("T_DIS.txt");
% dataANSYS=dataANSYS(2:end,:);
% plot(dataANSYS(:,1),dataANSYS(:,2),'r')



%% mass ratio
% 
% phiTMD2=phiTMD.^2;
% massratio=mTMD'.*phiTMD2;
% disp(massratio*100)
% 
% seq=u(1,:)';
% [psd_avg, f, psd_plot] = fft_transfer(1/dt,seq);
% 
% 
% %Plot the spectra
% figure(); hold on; grid on;
% plot(f,psd_plot,'b');
% xlabel('Frequency [Hz]'); ylabel('Spectral density [m^2/Hz]'); legend({'S'}); 
% xlim([0.06 0.1])





function result=P_eq(mode,temp_vec,Matrix)
    vec=temp_vec(:,mode);
    result=vec'*Matrix*vec;
end

function result=Cmatrix(mode,C,referencematrix)
    size_temp=size(referencematrix,1);
    C_temp=C(mode,:,:);
    result=reshape(C_temp,[size_temp,size_temp]);
end

function result=phiY(node,Mmapping,mode_vec,nModes)
    position_index=Mmapping.MatrixEqn(find(and(Mmapping.Node==node,Mmapping.DOF=='UY')));
    result=mode_vec(position_index,1:nModes);
end

function result=P_mode_eachpoint(Pmode,Mmapping,P0,points,omeg,t,mode_vec)
    for t1=1:points
        if sum(and(Mmapping.Node==t1,Mmapping.DOF=='UY'))==0
            result(t1,:)=0*P0*sin(omeg(Pmode)*t);
        else
            position_index=Mmapping.MatrixEqn(find(and(Mmapping.Node==t1,Mmapping.DOF=='UY')));
            result(t1,:)=mode_vec(position_index,Pmode)*P0*sin(omeg(Pmode)*t);
        end
    end
end

function result=Peq(Pmode,mode_vec,Mmapping,P_eachpoint,points,t)
    result=zeros(1,size(t,2));
    for t1=1:points
        if sum(and(Mmapping.Node==t1,Mmapping.DOF=='UY'))==0
            result=result+0*P_eachpoint(t1,:);
        else
            position_index=Mmapping.MatrixEqn(find(and(Mmapping.Node==t1,Mmapping.DOF=='UY')));
            result=result+mode_vec(position_index,Pmode)*P_eachpoint(t1,:);
        end
    end
end

% %% 每一阶单个TMD的最佳安装位置，及质量比计算
% clc
% clear
% load mode_vec
% load Stiffmatrix
% KMmapping = importmappingmatrix('KMatrix.mapping');
% % 感兴趣的模态（前9阶竖弯模态）
% modes=[2 3 6 9 15 21 23 29 33];
% % 导入桥面节点
% nodeondeck=importdata("NODEONDECK.txt");
% % 从前50阶提取感兴趣模态的向量
% mode_sel=mode_vec(:,modes);
% flag_sel=ones(size(mode_sel,1),size(mode_sel,2));
% deckdata_x=[];
% 
% % 提取桥面振型
% for k2=1:length(modes)
%     disp(strcat("正在提取第",num2str(k2),"桥面竖弯振型"))
%     for k1=1:length(nodeondeck)   
%         deckdata_x(k1,1)=nodeondeck(k1);
%         if sum(KMmapping((KMmapping.DOF=='UY'),:).Node==nodeondeck(k1)==1)==0
%             disp(strcat(num2str(nodeondeck(k1)),"节点无竖向自由度"))
%             deckdata_x(k1,k2+1)=0;
%         else
%             ydof_temp=KMmapping((KMmapping.DOF=='UY'),:);
%             ydof_position_temp=find(KMmapping((KMmapping.DOF=='UY'),:).Node==nodeondeck(k1)==1);
%             position_temp=ydof_temp(ydof_position_temp,1).MatrixEqn;
%             vec_temp=mode_sel(position_temp,k2);
%             flag_sel(position_temp,k2)=0;%0表示为桥面竖弯振型向量
%             deckdata_x(k1,k2+1)=vec_temp;
%         end
%     end
% end
% 
% % 创建标记
% for k3=1:size(flag_sel,1)
%     for k4=1:size(flag_sel,2)
%         if flag_sel(k3,k4)==0
%             mode_y_sel(k3,k4)=mode_sel(k3,k4);
%         else
%             mode_y_sel(k3,k4)=0;
%         end
%     end
% end
% 
% for k5=1:length(modes)
%     mode_m_deck(k5)=mode_y_sel(:,k5)'*M*mode_y_sel(:,k5);
%     disp(strcat("第",num2str(k5),"阶桥面竖弯模态质量为",num2str(mode_m_deck(k5))))
% end
% 
% for k6=1:length(modes)
%     [zhenxing_max_value(k6),zhenxing_max_position(k6)]=max(abs(mode_y_sel(:,k6)));
% end
% 
% m_tmd=147800;
% for k7=1:length(modes)
%     mode_m_tmd(k7)=m_tmd*zhenxing_max_value(k7)^2;
%     massratio(k7)=mode_m_tmd(k7)/mode_m_deck(k7);
%     disp(strcat("第",num2str(k7),"阶模态TMD的质量比为：",num2str(massratio(k7)*100),"%"))
% end




